/*
  The contents of this file are subject to the Initial Developer's Public
  License Version 1.0 (the "License"); you may not use this file except in
  compliance with the License. You may obtain a copy of the License here:
  http://www.flamerobin.org/license.html.

  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
  License for the specific language governing rights and limitations under
  the License.

  The Original Code is FlameRobin (TM).

  The Initial Developer of the Original Code is Milan Babuskov.

  Portions created by the original developer
  are Copyright (C) 2004 Milan Babuskov.

  All Rights Reserved.

  $Id$

  Contributor(s):
*/

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWindows headers
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif

#include "config/Config.h"
#include "metadata/column.h"
#include "metadata/database.h"
#include "treeitem.h"
#include "ugly.h"
//-----------------------------------------------------------------------------
TreeItem::TreeItem(myTreeCtrl *tree)
    : Observer()
{
    treeM = tree;
}
//-----------------------------------------------------------------------------
MetadataItem *TreeItem::getObservedMetadata()
{
    // tree item observes only one item.
    return (static_cast<MetadataItem *>(getFirstSubject()));
}
//-----------------------------------------------------------------------------
//! returns tree subnode that points to given metadata object
wxTreeItemId TreeItem::findSubNode(MetadataItem *item)
{
    wxTreeItemIdValue cookie;
    wxTreeItemId id = GetId();
    for (wxTreeItemId i = treeM->GetFirstChild(id, cookie); i.IsOk(); i = treeM->GetNextChild(id, cookie))
    {
        MetadataItem *s = treeM->getMetadataItem(i);
        if (s == item)
            return i;
    }
    return wxTreeItemId();
}
//-----------------------------------------------------------------------------
//! parent nodes are responsible for "insert" / "delete"
//! node is responsible for "update"
void TreeItem::update()
{
    wxTreeItemId id = GetId();
    if (!id.IsOk())
        return;

    MetadataItem *object = getObservedMetadata();
    if (!object)
        return;

    bool itemHadChildren =  treeM->ItemHasChildren(id);
    bool hideDisconnected = config().get("HideDisconnectedDatabases", false);

    // check current item
    if (treeM->GetItemText(id) != std2wx(object->getPrintableName()))
        treeM->SetItemText(id, std2wx(object->getPrintableName()));

    NodeType ndt = object->getType();
    bool affectedBySetting = (ndt == ntTable || ndt == ntView || ndt == ntProcedure);
    bool showColumns = !affectedBySetting || config().get("ShowColumnsInTree", true);

    // check subitems
    std::vector<MetadataItem *>temp;
    if (showColumns && object->getChildren(temp))                   // check if some tree node has to be added
    {
        wxTreeItemId previous;
        for (std::vector<MetadataItem *>::iterator i = temp.begin(); i != temp.end(); ++i)
        {
            // skip autogenerated domains
            if ((*i)->getType() == ntDomain && (*i)->isSystem())
                continue;

            if (hideDisconnected)       // don't add it
            {
                Database *d = dynamic_cast<Database *>(*i);
                if (d && !d->isConnected())
                    continue;
            }

            wxString dbh_name = std2wx((*i)->getPrintableName());
            wxTreeItemId item = findSubNode(*i);
            // add if needed
            if (!item.IsOk())
            {
                TreeItem *newitem = new TreeItem(treeM);
                (*i)->attachObserver(newitem);
                int image = treeM->getItemImage((*i)->getType());
                if (object->getType() == ntTable)
                {
                    Column *c = (Column *)(*i);
                    if (c->isPrimaryKey())
                        image = treeM->getItemImage(ntPrimaryKey);
                    else if (c->isComputed())
                        image = treeM->getItemImage(ntComputed);
                }

                if (previous.IsOk())
                    previous = treeM->InsertItem(id, previous, dbh_name, image, -1, newitem);
                else    // first
                    previous = treeM->PrependItem(id, dbh_name, image, -1, newitem);
            }
            else
            {                                   // change text if needed
                if (dbh_name != treeM->GetItemText(item))
                    treeM->SetItemText(item, dbh_name);
                previous = item;
            }
        }
    }

    // remove delete items - one by one
    bool has_deleted;
    do
    {
        // iterate through nodes of tree to see if something has to be removed
        has_deleted = false;
        wxTreeItemIdValue cookie;
        for (wxTreeItemId item = treeM->GetFirstChild(id, cookie); item.IsOk(); item = treeM->GetNextChild(id, cookie))
        {
            bool ok = false;        // check if item exists in vector
            for (std::vector<MetadataItem *>::iterator i = temp.begin(); i != temp.end(); ++i)
            {
                if (*i == treeM->getMetadataItem(item))
                {
                    ok = true;
                    if (hideDisconnected)   // remove if it's there
                    {
                        Database *d = dynamic_cast<Database *>(*i);
                        if (d && !d->isConnected())
                        {
                            ok = false;
                            break;
                        }
                    }
                }
            }
            if (!ok)
            {
                has_deleted = true;
                treeM->DeleteChildren(item);
                treeM->Delete(item);
                break;
            }
        }
    }
    while (has_deleted);

    if (treeM->ItemHasChildren(id))     // cosmetics
    {
        NodeType subAggItems [] = { ntTable, ntView, ntProcedure, ntFunction };
        bool was = false;
        for (unsigned int i = 0; i < sizeof(subAggItems)/sizeof(NodeType); ++i)
        {
            if (subAggItems[i] == object->getType())
            {
                treeM->Expand(id);
                was = true;
            }
        }
        if (!was && !itemHadChildren)
            treeM->SetItemBold(id, true);
    }
    else
        treeM->SetItemBold(id, false);

    if (object->orderedChildren())
        treeM->SortChildren(id);
}
//-----------------------------------------------------------------------------
