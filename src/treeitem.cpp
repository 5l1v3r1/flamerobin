/*
  The contents of this file are subject to the Initial Developer's Public
  License Version 1.0 (the "License"); you may not use this file except in
  compliance with the License. You may obtain a copy of the License here:
  http://www.flamerobin.org/license.html.

  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
  License for the specific language governing rights and limitations under
  the License.

  The Original Code is FlameRobin (TM).

  The Initial Developer of the Original Code is Milan Babuskov.

  Portions created by the original developer
  are Copyright (C) 2004 Milan Babuskov.

  All Rights Reserved.

  Contributor(s):
*/

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
    #pragma hdrstop
#endif

// for all others, include the necessary headers (this file is usually all you
// need because it includes almost all "standard" wxWindows headers
#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif

#include "ugly.h"
#include "metadata/column.h"
#include "config.h"
#include "treeitem.h"
//------------------------------------------------------------------------------
YTreeItem::YTreeItem(myTreeCtrl *tree)
	: YxObserver()
{
	treeM = tree;
}
//------------------------------------------------------------------------------
YxMetadataItem *YTreeItem::getObservedMetadata()
{
	// tree item observes only one item.
	return (static_cast<YxMetadataItem *>(getFirstObservedObject()));
}
//------------------------------------------------------------------------------
//! returns tree subnode that points to given metadata object
wxTreeItemId YTreeItem::findSubNode(YxMetadataItem *item)
{
	wxTreeItemIdValue cookie;
	wxTreeItemId id = GetId();
	for (wxTreeItemId i = treeM->GetFirstChild(id, cookie); i.IsOk(); i = treeM->GetNextChild(id, cookie))
	{
		YxMetadataItem *s = treeM->getMetadataItem(i);
		if (s == item)
			return i;
	}
	return wxTreeItemId();
}
//------------------------------------------------------------------------------
//! parent nodes are responsible for "insert" / "delete"
//! node is responsible for "update"
void YTreeItem::update()
{
	wxTreeItemId id = GetId();
	if (!id.IsOk())
		return;

	YxMetadataItem *object = getObservedMetadata();
	if (!object)
		return;

	bool itemHadChildren = 	treeM->ItemHasChildren(id);

	// check current item
	if (treeM->GetItemText(id) != std2wx(object->getPrintableName()))
		treeM->SetItemText(id, std2wx(object->getPrintableName()));

	NodeType ndt = object->getType();
	bool affectedBySetting = (ndt == ntTable || ndt == ntView || ndt == ntProcedure);
	bool showColumns = !affectedBySetting || config().get("ShowColumnsInTree", true);

	// check subitems
	std::vector<YxMetadataItem *>temp;
	if (showColumns && object->getChildren(temp))					// check if some tree node has to be added
	{
		wxTreeItemId previous;
		for (std::vector<YxMetadataItem *>::iterator i = temp.begin(); i != temp.end(); ++i)
		{
			// skip autogenerated domains
			if ((*i)->getType() == ntDomain && (*i)->isSystem())
				continue;

			wxString dbh_name = std2wx((*i)->getPrintableName());

			wxTreeItemId item = findSubNode(*i);
			if (!item.IsOk())											// add if needed
			{
				YTreeItem *newitem = new YTreeItem(treeM);
				(*i)->attach(newitem);
				int image = treeM->getItemImage((*i)->getType());
				if (object->getType() == ntTable)
				{
					YColumn *c = (YColumn *)(*i);
					if (c->isPrimaryKey())
						image = treeM->getItemImage(ntPrimaryKey);
					else if (c->isComputed())
						image = treeM->getItemImage(ntComputed);
				}

				if (previous.IsOk())
					previous = treeM->InsertItem(id, previous, dbh_name, image, -1, newitem);
				else	// first
					previous = treeM->PrependItem(id, dbh_name, image, -1, newitem);
			}
			else
			{									// change text if needed
				if (dbh_name != treeM->GetItemText(item))
					treeM->SetItemText(item, dbh_name);
				previous = item;
			}
		}
	}

	// something strange is going on here, so a little strange approach to fix it
	bool has_deleted;
	do
	{
		// iterate through nodes of tree to see if something has to be removed
		has_deleted = false;
		wxTreeItemIdValue cookie;
		for (wxTreeItemId item = treeM->GetFirstChild(id, cookie); item.IsOk(); item = treeM->GetNextChild(id, cookie))
		{
			bool ok = false;		// check if item exists in vector
			for (std::vector<YxMetadataItem *>::iterator i = temp.begin(); i != temp.end(); ++i)
				if (*i == treeM->getMetadataItem(item))
					ok = true;

			if (!ok)
			{
				has_deleted = true;
				treeM->DeleteChildren(item);
				treeM->Delete(item);
				break;
			}
		}
	}
	while (has_deleted);


	if (treeM->ItemHasChildren(id))		// cosmetics
	{
		NodeType subAggItems [] = { ntTable, ntView, ntProcedure, ntFunction };
		bool was = false;
		for (unsigned int i = 0; i < sizeof(subAggItems)/sizeof(NodeType); ++i)
		{
			if (subAggItems[i] == object->getType())
			{
				treeM->Expand(id);
				was = true;
			}
		}

		if (!was && !itemHadChildren)
			treeM->SetItemBold(id, true);

	}
	else
		treeM->SetItemBold(id, false);

    if (object->orderedChildren())
        treeM->SortChildren(id);
}
//------------------------------------------------------------------------------
